from appium.options.android import UiAutomator2Options
from appium import webdriver
from selenium.webdriver.common.action_chains import ActionChains  # W3C Actions 사용
from selenium.webdriver.common.actions.pointer_input import PointerInput  # 포인터 입력 사용
import subprocess
import time

# 성능 데이터 수집 함수 (ADB 명령어 실행)
def collect_performance_data():
    # ADB 명령어 실행 (프레임 속도 수집)
    result = subprocess.run(['adb', 'shell', 'dumpsys', 'gfxinfo', 'com.Cryptect.Mercenary'], capture_output=True, text=True)
    
    # 수집한 데이터를 지정된 경로에 성능 로그 파일로 저장
    log_file_path = r'C:\Users\bobGate\Downloads\테스트 자동화 로그파일\performance_data.txt'  # 파일 경로
    with open(log_file_path, 'w') as file:
        file.write(result.stdout)

    # CPU 사용량 수집
    cpu_usage = subprocess.run(['adb', 'shell', 'top', '-n', '1', '|', 'grep', 'com.Cryptect.Mercenary'], capture_output=True, text=True)
    with open(log_file_path, 'a') as file:  # 기존 파일에 추가
        file.write(f"\nCPU 사용량: {cpu_usage.stdout}")

    # 메모리 사용량 수집
    memory_usage = subprocess.run(['adb', 'shell', 'dumpsys', 'meminfo', 'com.Cryptect.Mercenary'], capture_output=True, text=True)
    with open(log_file_path, 'a') as file:
        file.write(f"\n메모리 사용량: {memory_usage.stdout}")
    
    # 배터리 사용량 수집
    battery_info = subprocess.run(['adb', 'shell', 'dumpsys', 'battery'], capture_output=True, text=True)
    with open(log_file_path, 'a') as file:
        file.write(f"\n배터리 상태: {battery_info.stdout}")
    
    # 네트워크 데이터 사용량 수집
    data_usage = subprocess.run(['adb', 'shell', 'dumpsys', 'netstats'], capture_output=True, text=True)
    with open(log_file_path, 'a') as file:
        file.write(f"\n네트워크 데이터 사용량: {data_usage.stdout}")

    # 발열 수준 수집
    temperature_info = subprocess.run(['adb', 'shell', 'dumpsys', 'battery', '|', 'grep', 'temperature'], capture_output=True, text=True)
    with open(log_file_path, 'a') as file:
        file.write(f"\n기기 발열(온도): {temperature_info.stdout}")

    # 프레임 드롭 발생 빈도 수집
    frame_drop_info = subprocess.run(['adb', 'shell', 'dumpsys', 'gfxinfo', 'com.Cryptect.Mercenary', '|', 'grep', 'Janky'], capture_output=True, text=True)
    with open(log_file_path, 'a') as file:
        file.write(f"\n프레임 드롭 빈도: {frame_drop_info.stdout}")

# 특이사항 발생 시 스크린샷을 촬영하는 함수
def take_screenshot(driver, issue_desc):
    timestamp = time.strftime("%Y%m%d-%H%M%S")
    screenshot_path = f'C:/Users/bobGate/Downloads/테스트 자동화 로그파일/screenshot_{issue_desc}_{timestamp}.png'
    driver.save_screenshot(screenshot_path)
    print(f"특이사항 발생: {issue_desc}, 스크린샷 저장 위치: {screenshot_path}")

# 특이사항을 체크하는 함수 (FPS, CPU, 메모리 등)
def check_for_anomalies():
    # FPS가 30 이하로 떨어졌을 때
    fps = 25  # 예시로 FPS를 직접 설정 (실제는 FPS 수집 함수 필요)
    if fps < 30:
        take_screenshot(driver, "Low_FPS")

    # CPU 사용량이 90% 이상일 때
    cpu_usage = 92  # 예시로 CPU 사용량 직접 설정 (실제는 수집 함수 필요)
    if cpu_usage > 90:
        take_screenshot(driver, "High_CPU_Usage")

    # 메모리 사용량이 1GB 이상일 때
    memory_usage = 1200  # 예시로 메모리 사용량 직접 설정 (실제는 수집 함수 필요)
    if memory_usage > 1024:
        take_screenshot(driver, "High_Memory_Usage")

    # 배터리 온도가 40도 이상일 때
    temperature = 42  # 예시로 온도를 직접 설정 (실제는 수집 함수 필요)
    if temperature > 40:
        take_screenshot(driver, "High_Temperature")

# Appium 옵션 설정 (capabilities)
options = UiAutomator2Options()
options.platform_name = "Android"
options.platform_version = "13"  # 실제 기기 Android 버전
options.device_name = "R3CNC032JZM"  # ADB로 확인한 실제 기기명
options.app_package = "com.Cryptect.Mercenary"  # 게임의 패키지 이름
options.app_activity = "com.unity3d.player.UnityPlayerActivity"  # 메인 액티비티
options.automation_name = "UiAutomator2"  # Android 자동화 프레임워크
options.no_reset = True  # 앱 데이터를 리셋하지 않음

# Appium 서버 연결 (루트 경로 사용)
driver = webdriver.Remote('http://127.0.0.1:4723', options=options)

# 게임 실행 후 30초 동안 대기
time.sleep(30)

# 포인터 액션 정의 (터치 기반 이벤트)
pointer = PointerInput(PointerInput.TOUCH, "finger")
actions = ActionChains(driver)

# 터치 액션 정의 (각 좌표에서 수행)
def tap_at_coordinates(x, y):
    actions.w3c_actions.pointer_action.move_to_location(x, y)
    actions.w3c_actions.pointer_action.pointer_down()
    actions.w3c_actions.pointer_action.pointer_up()
    actions.perform()

# 1. X 232 / Y 897 터치
tap_at_coordinates(232, 897)
time.sleep(5)  # 5초 대기

# 2. X 892 / Y 405 터치
tap_at_coordinates(892, 405)
time.sleep(5)  # 5초 대기

# 3. X 2133 / Y 925 20번 터치
for _ in range(20):
    tap_at_coordinates(2133, 925)
    time.sleep(5)  # 5초 대기

# 4. X 1622 / Y 929 터치
tap_at_coordinates(1622, 929)
time.sleep(5)  # 5초 대기

# 5. X 2083 / Y 829 터치
tap_at_coordinates(2083, 829)
time.sleep(5)  # 5초 대기

# 6. X 1622 / Y 929 터치
tap_at_coordinates(1622, 929)
time.sleep(5)  # 5초 대기

# 7. X 2163 / Y 650 터치
tap_at_coordinates(2163, 650)
time.sleep(5)  # 5초 대기

# 8. X 285 / Y 650 터치
tap_at_coordinates(285, 650)
time.sleep(5)  # 5초 대기

# 9. X 2176 / Y 411 터치
tap_at_coordinates(2176, 411)
time.sleep(5)  # 5초 대기

# 10. X 521 / Y 929 터치
tap_at_coordinates(521, 929)
time.sleep(5)  # 5초 대기

# 11. X 521 / Y 929 터치 (다시 터치)
tap_at_coordinates(521, 929)
time.sleep(30)  # 30초 대기

# 12. X 1924 / Y 1048 터치
tap_at_coordinates(1924, 1048)

# 600초 동안 카운트다운 (60초마다 남은 시간 출력)
remaining_time = 600
while remaining_time > 0:
    time.sleep(60)
    remaining_time -= 60
    print(f"남은 시간: {remaining_time}초")

    # 특이사항 체크
    check_for_anomalies()

# 성능 데이터 수집 함수 실행
collect_performance_data()

# 테스트 종료 (Appium 세션 종료)
driver.quit()
